

export const javaOops = [
  {
    question: "Which of the following is not a feature of OOPs?",
    options: ["Encapsulation", "Polymorphism", "Platform independence", "Inheritance"],
    answer: "Platform independence",
  },
  {
    question: "Which of the following is not an OOPs concept?",
    options: ["Abstraction", "Polymorphism", "Compilation", "Inheritance"],
    answer: "Compilation",
  },
  {
    question: "Which concept allows reusability in OOPs?",
    options: ["Inheritance", "Polymorphism", "Abstraction", "Encapsulation"],
    answer: "Inheritance",
  },
  {
    question: "What is the main principle of Encapsulation?",
    options: ["Hiding implementation details", "Inheriting properties", "Achieving polymorphism", "Reusing code"],
    answer: "Hiding implementation details",
  },
  {
    question: "What is Polymorphism in Java?",
    options: ["One class having multiple parents", "One object behaving in multiple ways", "Multiple variables with same name", "None of the above"],
    answer: "One object behaving in multiple ways",
  },
  {
    question: "Which keyword is used to inherit a class in Java?",
    options: ["implement", "extends", "import", "inherits"],
    answer: "extends",
  },
  {
    question: "What is Method Overriding in Java?",
    options: ["Defining multiple methods with same name but different parameters", "Redefining a method of a superclass in a subclass", "Using multiple constructors in a class", "Calling a method from another method"],
    answer: "Redefining a method of a superclass in a subclass",
  },
  {
    question: "Which of the following allows multiple inheritance in Java?",
    options: ["Classes", "Interfaces", "Abstract classes", "Packages"],
    answer: "Interfaces",
  },
  {
    question: "What does the ‘this’ keyword refer to?",
    options: ["Parent class object", "Current class object", "Superclass constructor", "None of these"],
    answer: "Current class object",
  },
  {
    question: "What does the ‘super’ keyword refer to?",
    options: ["Refers to current object", "Refers to parent class object", "Creates an object of superclass", "Calls static method of superclass"],
    answer: "Refers to parent class object",
  },
  {
    question: "What is constructor chaining in Java?",
    options: ["Calling multiple constructors one after another in different classes", "Calling one constructor from another constructor in the same or superclass", "Calling methods inside a constructor", "Calling constructors recursively"],
    answer: "Calling one constructor from another constructor in the same or superclass",
  },
  {
    question: "What type of binding is used in method overloading?",
    options: ["Static binding", "Dynamic binding", "Late binding", "None"],
    answer: "Static binding",
  },
  {
    question: "What type of binding is used in method overriding?",
    options: ["Static binding", "Dynamic binding", "Compile-time binding", "None"],
    answer: "Dynamic binding",
  },
  {
    question: "Which of the following cannot be instantiated directly?",
    options: ["Interface", "Abstract class", "Both Interface and Abstract class", "None"],
    answer: "Both Interface and Abstract class",
  },
  {
    question: "What happens if a subclass defines a method with a lower access modifier?",
    options: ["It overrides successfully", "It causes a compilation error", "It runs but gives a warning", "It hides the superclass method"],
    answer: "It causes a compilation error",
  },
  {
    question: "Which of the following is an example of runtime polymorphism?",
    options: ["Method overloading", "Method overriding", "Constructor overloading", "Static method calling"],
    answer: "Method overriding",
  },
  {
    question: "When a parent class reference refers to a child class object, it is called?",
    options: ["Compilation error", "Runtime error", "Upcasting", "Downcasting"],
    answer: "Upcasting",
  },
  {
    question: "What is required to perform downcasting in Java?",
    options: ["Explicit casting", "Implicit casting", "Constructor", "None"],
    answer: "Explicit casting",
  },
  {
    question: "Which statement about an interface reference variable is true?",
    options: ["It can hold reference of an object of implementing class", "It cannot refer to any object", "It can refer only to abstract class", "It can only store null values"],
    answer: "It can hold reference of an object of implementing class",
  },
  {
    question: "What happens when an abstract method is not overridden in a subclass?",
    options: ["Compilation error", "Runtime error", "Works fine", "Only a warning"],
    answer: "Compilation error",
  },
  {
    question: "Which method is called automatically when an object is created?",
    options: ["start()", "init()", "constructor", "finalize()"],
    answer: "constructor",
  },
  {
    question: "Which statement about 'final' keyword is true?",
    options: ["Final class can be inherited", "Final variable can be reassigned", "Final method cannot be overridden", "Final variable can be left uninitialized"],
    answer: "Final method cannot be overridden",
  },
  {
    question: "Which of the following cannot be overridden?",
    options: ["Static methods", "Abstract methods", "Public methods", "Protected methods"],
    answer: "Static methods",
  },
  {
    question: "What is true about object creation in inheritance?",
    options: ["Only subclass constructor is called", "Only superclass constructor is called", "Superclass constructor is called before subclass constructor", "Subclass constructor is called before superclass constructor"],
    answer: "Superclass constructor is called before subclass constructor",
  },
  {
    question: "What does the 'this' keyword refer to in Java?",
    options: ["The parent class object", "The current class object", "The superclass constructor", "None of these"],
    answer: "The current class object",
  },
  {
    question: "Which statement about 'super()' is true?",
    options: ["It must be the last statement in a constructor", "It must be the first statement in a constructor", "It can be called from any method", "It can be used multiple times in a constructor"],
    answer: "It must be the first statement in a constructor",
  },
  {
    question: "Which keyword prevents method overriding?",
    options: ["abstract", "static", "final", "private"],
    answer: "final",
  },
  {
    question: "What happens if you create an object of an abstract class?",
    options: ["It compiles successfully", "It throws a runtime exception", "It causes a compile-time error", "It works only if constructor is defined"],
    answer: "It causes a compile-time error",
  },
  {
    question: "Which OOP principle helps in achieving security through hiding implementation?",
    options: ["Abstraction", "Encapsulation", "Polymorphism", "Inheritance"],
    answer: "Encapsulation",
  },
  {
    question: "Which of the following supports runtime polymorphism?",
    options: ["Abstract classes", "Interfaces", "Both a and b", "None"],
    answer: "Both a and b",
  },
  {
    question: "Which access specifier is most restrictive in Java?",
    options: ["private", "protected", "default", "public"],
    answer: "private",
  },
  {
    question: "Which OOP concept binds data and functions together?",
    options: ["Abstraction", "Encapsulation", "Inheritance", "Polymorphism"],
    answer: "Encapsulation",
  },
  {
    question: "Which of these keywords is used to define a class?",
    options: ["define", "class", "struct", "object"],
    answer: "class",
  },
  {
    question: "Can a constructor be abstract in Java?",
    options: ["Yes", "No", "Only in abstract class", "Only in interfaces"],
    answer: "No",
  },
  {
    question: "Can we overload constructors in Java?",
    options: ["Yes", "No", "Only if abstract", "Only if final"],
    answer: "Yes",
  },
  {
    question: "Can we override a static method in Java?",
    options: ["Yes", "No", "Only in subclass", "Only with abstract keyword"],
    answer: "No",
  },
  {
    question: "Which class is the parent of all classes in Java?",
    options: ["Object", "Main", "Super", "Class"],
    answer: "Object",
  },
  {
    question: "What does encapsulation mainly protect?",
    options: ["Data", "Methods", "Classes", "Objects"],
    answer: "Data",
  },
  {
    question: "Which concept helps achieve abstraction in Java?",
    options: ["Interfaces and Abstract classes", "Static methods", "Constructors", "Packages"],
    answer: "Interfaces and Abstract classes",
  },
  {
    question: "What is the default access modifier for class members?",
    options: ["private", "protected", "default", "public"],
    answer: "default",
  },
  {
    question: "Can an abstract class have a constructor?",
    options: ["Yes", "No", "Only if final", "Only if static"],
    answer: "Yes",
  },
  {
    question: "Can interfaces contain constructors?",
    options: ["Yes", "No", "Sometimes", "Only abstract"],
    answer: "No",
  },
  {
    question: "What is the default superclass of all classes in Java?",
    options: ["Object class", "Super class", "Main class", "Base class"],
    answer: "Object class",
  },
  {
    question: "Which keyword is used to prevent inheritance?",
    options: ["static", "final", "abstract", "private"],
    answer: "final",
  },
  {
    question: "Which keyword is used to implement multiple inheritance in Java?",
    options: ["extends", "implements", "inherits", "inheritsFrom"],
    answer: "implements",
  },
  {
    question: "Which concept allows an object to take many forms?",
    options: ["Encapsulation", "Abstraction", "Polymorphism", "Inheritance"],
    answer: "Polymorphism",
  },
  {
    question: "Can we instantiate an interface?",
    options: ["Yes", "No", "Only abstractly", "Only in subclass"],
    answer: "No",
  },
  {
    question: "Which class method is called before garbage collection?",
    options: ["destroy()", "finalize()", "dispose()", "end()"],
    answer: "finalize()",
  },
  {
    question: "Which concept is used to achieve dynamic method dispatch?",
    options: ["Method overriding", "Method overloading", "Constructor chaining", "Encapsulation"],
    answer: "Method overriding",
  },
  {
    question: "Which keyword is used to define an abstract method?",
    options: ["abstract", "static", "final", "private"],
    answer: "abstract",
  },
  {
    question: "Which of the following is the pillar of OOP that hides internal details?",
    options: ["Abstraction", "Inheritance", "Polymorphism", "Encapsulation"],
    answer: "Encapsulation",
  },
  {
    question: "Which OOP concept allows one class to acquire properties of another?",
    options: ["Encapsulation", "Inheritance", "Polymorphism", "Abstraction"],
    answer: "Inheritance",
  },
  {
    question: "Which keyword is used to inherit a class in Java?",
    options: ["this", "extends", "super", "implements"],
    answer: "extends",
  },
  {
    question: "Which keyword is used to call the parent class constructor?",
    options: ["super", "this", "parent", "base"],
    answer: "super",
  },
  {
    question: "What is it called when two or more methods have the same name but different parameters?",
    options: ["Method overriding", "Method overloading", "Encapsulation", "Polymorphism"],
    answer: "Method overloading",
  },
  {
    question: "What is method overriding?",
    options: [
      "Defining multiple methods with the same name in a class",
      "Changing the behavior of a parent class method in a subclass",
      "Using multiple classes in one program",
      "Hiding data from users",
    ],
    answer: "Changing the behavior of a parent class method in a subclass",
  },
  {
    question: "Which of the following cannot be overridden?",
    options: ["Static methods", "Instance methods", "Abstract methods", "Final variables"],
    answer: "Static methods",
  },
  {
    question: "What is an abstract class in Java?",
    options: [
      "A class that cannot be extended",
      "A class that cannot be instantiated",
      "A class that contains only static methods",
      "A class without constructors",
    ],
    answer: "A class that cannot be instantiated",
  },
  {
    question: "Which of the following OOP principles promotes code reuse?",
    options: ["Encapsulation", "Inheritance", "Polymorphism", "Abstraction"],
    answer: "Inheritance",
  },
  {
    question: "What is runtime polymorphism in Java?",
    options: [
      "Method overloading",
      "Method overriding",
      "Encapsulation",
      "Abstraction",
    ],
    answer: "Method overriding",
  },
  {
    question: "Which of the following can be used to achieve multiple inheritance in Java?",
    options: ["Abstract class", "Interface", "Inheritance", "Polymorphism"],
    answer: "Interface",
  },
  {
    question: "Which keyword prevents a class from being inherited?",
    options: ["abstract", "final", "static", "const"],
    answer: "final",
  },
  {
    question: "What is the purpose of a constructor?",
    options: [
      "To destroy objects",
      "To initialize objects",
      "To inherit data",
      "To override methods",
    ],
    answer: "To initialize objects",
  },
  {
    question: "Can a constructor be overloaded in Java?",
    options: ["Yes", "No"],
    answer: "Yes",
  },
  {
    question: "Which of the following statements is true about interfaces?",
    options: [
      "Interfaces can contain constructors",
      "Interfaces can have method implementations by default",
      "Interfaces cannot have constructors",
      "Interfaces cannot be implemented by classes",
    ],
    answer: "Interfaces cannot have constructors",
  },
  {
    question: "What is encapsulation in Java?",
    options: [
      "Wrapping data and methods together",
      "Hiding methods from other classes",
      "Using multiple classes together",
      "Extending one class to another",
    ],
    answer: "Wrapping data and methods together",
  },
  {
    question: "Which of these access modifiers makes members visible only within the same package?",
    options: ["public", "private", "protected", "default"],
    answer: "default",
  },
  {
    question: "Can we instantiate an abstract class?",
    options: ["Yes", "No"],
    answer: "No",
  },
  {
    question: "Which method is called automatically when an object is created?",
    options: ["main()", "finalize()", "constructor", "toString()"],
    answer: "constructor",
  },
  {
    question: "Can a constructor return a value?",
    options: ["Yes", "No"],
    answer: "No",
  },
  {
    question: "What is the keyword used to refer to the current object?",
    options: ["super", "this", "self", "current"],
    answer: "this",
  },
  {
    question: "What is a class in Java?",
    options: [
      "An object instance",
      "A blueprint for creating objects",
      "A variable type",
      "A library method",
    ],
    answer: "A blueprint for creating objects",
  },
  {
    question: "Which keyword is used to define an interface in Java?",
    options: ["class", "extends", "interface", "implements"],
    answer: "interface",
  },
  {
    question: "Which concept allows a subclass to define its own behavior for a parent class method?",
    options: ["Encapsulation", "Polymorphism", "Inheritance", "Abstraction"],
    answer: "Polymorphism",
  },
  {
    question: "Which concept hides the internal details and shows only the functionality?",
    options: ["Encapsulation", "Inheritance", "Polymorphism", "Abstraction"],
    answer: "Abstraction",
  },
  {
    question: "Can we override static methods in Java?",
    options: ["Yes", "No"],
    answer: "No",
  },
  {
    question: "Which keyword is used to make a variable unchangeable?",
    options: ["final", "static", "const", "immutable"],
    answer: "final",
  },
  {
    question: "Which of these defines a relationship between classes?",
    options: ["Encapsulation", "Inheritance", "Polymorphism", "Abstraction"],
    answer: "Inheritance",
  },
  {
    question: "Can an abstract class have constructors?",
    options: ["Yes", "No"],
    answer: "Yes",
  },
  {
    question: "Which of these supports runtime polymorphism?",
    options: ["Overloading", "Overriding", "Encapsulation", "Abstraction"],
    answer: "Overriding",
  },
  {
    question: "Which method is called just before an object is garbage collected?",
    options: ["finalize()", "destroy()", "delete()", "remove()"],
    answer: "finalize()",
  },
  {
    question: "Can we declare an interface method as private?",
    options: ["Yes", "No"],
    answer: "No",
  },
  {
    question: "Which OOP concept promotes flexibility and reusability of code?",
    options: ["Encapsulation", "Abstraction", "Polymorphism", "Inheritance"],
    answer: "Polymorphism",
  },
  {
    question: "Which keyword is used to call a parent class constructor?",
    options: ["super", "this", "base", "parent"],
    answer: "super",
  },
  {
    question: "Can we have multiple constructors in a class?",
    options: ["Yes", "No"],
    answer: "Yes",
  },
  {
    question: "Which class is the superclass of all classes in Java?",
    options: ["Object", "Class", "Main", "Base"],
    answer: "Object",
  },
  {
    question: "What is method overloading based on?",
    options: ["Return type", "Number and type of parameters", "Access modifier", "Object type"],
    answer: "Number and type of parameters",
  },
  {
    question: "What is composition in OOP?",
    options: [
      "A relationship where one class owns another",
      "Multiple classes extending the same class",
      "Overriding multiple methods",
      "Creating interfaces within a class",
    ],
    answer: "A relationship where one class owns another",
  },
  {
    question: "Which keyword is used to prevent method overriding?",
    options: ["abstract", "final", "static", "private"],
    answer: "final",
  },
  {
    question: "What does polymorphism mean?",
    options: [
      "Many forms",
      "Single form",
      "Hidden data",
      "Multiple constructors",
    ],
    answer: "Many forms",
  },
  {
    question: "Which of the following is true about constructors?",
    options: [
      "They must have a return type",
      "They must have the same name as the class",
      "They are inherited by subclasses",
      "They can be abstract",
    ],
    answer: "They must have the same name as the class",
  },
  {
    question: "Which of the following statements about inheritance is false?",
    options: [
      "It helps in code reusability",
      "A subclass can inherit from multiple classes",
      "A subclass can override parent methods",
      "Superclass constructor can be called using super()",
    ],
    answer: "A subclass can inherit from multiple classes",
  },
  {
    question: "Can a constructor be static?",
    options: ["Yes", "No"],
    answer: "No",
  },
  {
    question: "Which of these is used to implement abstraction?",
    options: ["Classes", "Interfaces", "Constructors", "Packages"],
    answer: "Interfaces",
  },
  {
    question: "What is aggregation in OOP?",
    options: [
      "A has-a relationship",
      "An is-a relationship",
      "A part-of relationship",
      "A subclass relationship",
    ],
    answer: "A has-a relationship",
  },
  {
    question: "Which of the following is not a valid access modifier in Java?",
    options: ["public", "protected", "default", "global"],
    answer: "global",
  },
  {
    question: "Can abstract classes have static methods?",
    options: ["Yes", "No"],
    answer: "Yes",
  },
  {
    question: "Can an interface extend another interface?",
    options: ["Yes", "No"],
    answer: "Yes",
  },
  {
    question: "Which OOP principle ensures that implementation details are hidden?",
    options: ["Abstraction", "Inheritance", "Polymorphism", "Encapsulation"],
    answer: "Abstraction",
  },
  {
    question: "Which of the following defines behavior shared by all objects?",
    options: ["Object class", "Interface", "Abstract class", "Package"],
    answer: "Object class",
  },
];
