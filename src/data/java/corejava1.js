export const coreJava = [
  {
    question: "What are static blocks and static initializers in Java?",
    options: [
      "Blocks that run when an object is created",
      "Blocks that run when a class is loaded",
      "Blocks that run inside methods",
      "Blocks that run before JVM starts"
    ],
    answer: "Blocks that run when a class is loaded"
  },
  {
    question: "How can one constructor call another constructor in Java?",
    options: ["Using super()", "Using this()", "Using call()", "Using init()"],
    answer: "Using this()"
  },
  {
    question: "What is method overriding in Java?",
    options: [
      "Same method name with different parameters",
      "Same method signature in subclass",
      "Using static methods with same name",
      "Writing two methods with same body"
    ],
    answer: "Same method signature in subclass"
  },
  {
    question: "What is the super keyword in Java?",
    options: [
      "A keyword to call subclass methods",
      "A keyword to access parent class members",
      "A keyword to create objects",
      "A keyword to access interfaces"
    ],
    answer: "A keyword to access parent class members"
  },
  {
    question: "Difference between method overloading and overriding?",
    options: [
      "Overloading is runtime, overriding is compile time",
      "Overloading is within class, overriding is in subclass",
      "Both are same",
      "Both require inheritance"
    ],
    answer: "Overloading is within class, overriding is in subclass"
  },
  {
    question: "Difference between abstract class and interface?",
    options: [
      "Interfaces allow constructors",
      "Abstract classes cannot have methods",
      "Interfaces support multiple inheritance",
      "Abstract classes must include variables only"
    ],
    answer: "Interfaces support multiple inheritance"
  },
  {
    question: "Why is Java platform independent?",
    options: [
      "Because of JVM",
      "Because of JRE",
      "Because of OS features",
      "Because of hardware optimization"
    ],
    answer: "Because of JVM"
  },
  {
    question: "What is method overloading in Java?",
    options: [
      "Same method name, different parameters",
      "Overriding parent method",
      "Using super keyword",
      "Using same method in interface"
    ],
    answer: "Same method name, different parameters"
  },
  {
    question: "Difference between C++ and Java?",
    options: [
      "Java supports pointers, C++ does not",
      "Java does not support pointers directly",
      "C++ is platform independent",
      "Java supports multiple inheritance"
    ],
    answer: "Java does not support pointers directly"
  },
  {
    question: "What is JIT compiler?",
    options: [
      "Compiler that converts code at runtime",
      "Compiler used for JVM installation",
      "Compiler that optimizes C++ code",
      "Compiler for debugging"
    ],
    answer: "Compiler that converts code at runtime"
  },
  {
    question: "What is bytecode in Java?",
    options: [
      "Machine code",
      "Code generated by JVM",
      "Intermediate code generated by compiler",
      "Source code"
    ],
    answer: "Intermediate code generated by compiler"
  },
  {
    question: "Difference between this() and super()?",
    options: [
      "this() calls parent constructor, super() calls same class constructor",
      "this() calls same class constructor, super() calls parent constructor",
      "Both call parent constructor",
      "Both call same class constructor"
    ],
    answer: "this() calls same class constructor, super() calls parent constructor"
  },
  {
    question: "What is a class?",
    options: [
      "Instance of an object",
      "Blueprint for objects",
      "Package of methods",
      "Memory block"
    ],
    answer: "Blueprint for objects"
  },
  {
    question: "What is an object?",
    options: [
      "Instance of a class",
      "A method inside a class",
      "A constructor",
      "A data type"
    ],
    answer: "Instance of a class"
  },
  {
    question: "What is a method in Java?",
    options: [
      "Block of code executed when object is created",
      "Block of statements performing a task",
      "Variable inside a class",
      "Memory block"
    ],
    answer: "Block of statements performing a task"
  },
  {
    question: "What is encapsulation?",
    options: [
      "Hiding data using classes",
      "Wrapping data and methods together",
      "Making methods private",
      "Using interfaces instead of classes"
    ],
    answer: "Wrapping data and methods together"
  },
  {
    question: "Why is main() method public static void?",
    options: [
      "Public for JVM access, static without object, void returns nothing",
      "Public for inheritance, static for speed, void for memory",
      "Static for class loading, void for objects",
      "Public for users"
    ],
    answer: "Public for JVM access, static without object, void returns nothing"
  },
  {
    question: "Explain main() method in Java.",
    options: [
      "Starting point of Java program",
      "Method to create objects",
      "Method to compile classes",
      "Memory handler method"
    ],
    answer: "Starting point of Java program"
  },
  {
    question: "What is a constructor in Java?",
    options: [
      "A method to destroy objects",
      "A special method to initialize objects",
      "A static block",
      "A normal method"
    ],
    answer: "A special method to initialize objects"
  },
  {
    question: "Difference between length and length()?",
    options: [
      "length is for strings, length() for arrays",
      "length() is for strings, length is for arrays",
      "Both same",
      "Both used for classes"
    ],
    answer: "length() is for strings, length is for arrays"
  },
  {
    question: "What is ASCII Code?",
    options: [
      "Character encoding using 16 bits",
      "7-bit or 8-bit character encoding for English characters",
      "32-bit Unicode encoding",
      "Binary code for images"
    ],
    answer: "7-bit or 8-bit character encoding for English characters"
  },
  {
    question: "What is Unicode?",
    options: [
      "A 7-bit character system",
      "A universal 16-bit or more character encoding standard",
      "Code used only for Java",
      "Encoding used for numbers only"
    ],
    answer: "A universal 16-bit or more character encoding standard"
  },
  {
    question: "Difference between character constant and string constant?",
    options: [
      "'A' is string, \"A\" is char",
      "Char constant uses double quotes, string uses single",
      "'A' is char and \"A\" is string",
      "Both are same"
    ],
    answer: "'A' is char and \"A\" is string"
  },
  {
    question: "What are constants in Java?",
    options: [
      "Variables that cannot be changed",
      "Methods that cannot be overridden",
      "Objects that are final",
      "Static blocks"
    ],
    answer: "Variables that cannot be changed"
  },
  {
    question: "Difference between >> and >>> operators?",
    options: [
      ">> is unsigned shift, >>> is signed shift",
      ">> preserves sign, >>> does not preserve sign",
      "Both preserve sign",
      "Both discard sign"
    ],
    answer: ">> preserves sign, >>> does not preserve sign"
  },
  {
    question: "Java coding standards for classes include:",
    options: [
      "Class name should start with lowercase",
      "Class name should be uppercase",
      "Class name should be all caps",
      "Class name should contain spaces"
    ],
    answer: "Class name should be uppercase"
  },
  {
    question: "Java coding standards for interfaces include:",
    options: [
      "Interface names should start with lowercase",
      "Interface names should be all lowercase",
      "Interface names should start with uppercase and be nouns/adjectives",
      "Interface names must start with I_ prefix"
    ],
    answer: "Interface names should start with uppercase and be nouns/adjectives"
  },
  {
    question: "Java coding standards for methods include:",
    options: [
      "Method names should start with uppercase",
      "Method names should be all caps",
      "Method names should start with lowercase letters",
      "Method names should begin with underscore"
    ],
    answer: "Method names should start with lowercase letters"
  },
  {
    question: "Java coding standards for variables include:",
    options: [
      "Variables must start with uppercase",
      "Variables must be uppercase always",
      "Variables should start with lowercase letters",
      "Variables should be single characters only"
    ],
    answer: "Variables should start with lowercase letters"
  },
  {
    question: "Java coding standards for constants include:",
    options: [
      "Constants should be lowercase",
      "Constants should be uppercase with underscores",
      "Constants should be camelCase",
      "Constants should be numeric only"
    ],
    answer: "Constants should be uppercase with underscores"
  },
  {
    question: "Difference between overriding and overloading?",
    options: [
      "Overriding is within same class, overloading is subclass",
      "Overloading is within same class, overriding is between classes",
      "Both occur at runtime",
      "Both require inheritance"
    ],
    answer: "Overloading is within same class, overriding is between classes"
  },
  {
    question: "What is IS-A relationship in Java?",
    options: [
      "Association between methods",
      "Inheritance relationship",
      "Encapsulation relationship",
      "Aggregation relationship"
    ],
    answer: "Inheritance relationship"
  },
  {
    question: "What is HAS-A relationship in Java?",
    options: [
      "Inheritance",
      "Aggregation or composition relationship",
      "Polymorphism",
      "Encapsulation"
    ],
    answer: "Aggregation or composition relationship"
  },
  {
    question: "Difference between IS-A and HAS-A?",
    options: [
      "IS-A is composition, HAS-A is inheritance",
      "IS-A is inheritance, HAS-A is composition/aggregation",
      "Both are same",
      "IS-A is for interfaces only"
    ],
    answer: "IS-A is inheritance, HAS-A is composition/aggregation"
  },
  {
    question: "What does instanceof operator do?",
    options: [
      "Checks if object belongs to a class",
      "Creates an object",
      "Deletes an object",
      "Converts object to class"
    ],
    answer: "Checks if object belongs to a class"
  },
  {
    question: "What does null mean in Java?",
    options: [
      "Refers to an empty string",
      "Refers to zero",
      "Refers to no object reference",
      "Refers to undefined variable"
    ],
    answer: "Refers to no object reference"
  },
  {
    question: "Can we have multiple classes in a single file?",
    options: [
      "No, only one class allowed",
      "Yes, but only one public class allowed",
      "Yes, all classes must be public",
      "No, Java compiler blocks it"
    ],
    answer: "Yes, but only one public class allowed"
  },
  {
    question: "What access modifiers are allowed for top-level class?",
    options: ["public and default", "private", "protected", "final only"],
    answer: "public and default"
  },
  {
    question: "What are packages in Java?",
    options: [
      "Collections of methods only",
      "Mechanism to group related classes",
      "A type of variable",
      "JVM memory blocks"
    ],
    answer: "Mechanism to group related classes"
  },
  {
    question: "Can we have more than one package statement in a source file?",
    options: ["Yes", "No", "Only in Java 11+", "Only if class is abstract"],
    answer: "No"
  },
  {
    question: "Can we define package statement after import statement in Java?",
    options: ["Yes", "No", "Only in Java 8+", "Only in interfaces"],
    answer: "No"
  },
  {
    question: "What are identifiers in Java?",
    options: [
      "Keywords used in Java",
      "Symbols used to name variables, classes, and methods",
      "Special characters",
      "Numbers only"
    ],
    answer: "Symbols used to name variables, classes, and methods"
  },
  {
    question: "What are access modifiers in Java?",
    options: [
      "Modifiers that control class memory",
      "Modifiers that control visibility",
      "Modifiers for loops",
      "Modifiers for exceptions"
    ],
    answer: "Modifiers that control visibility"
  },
  {
    question: "Difference between access specifiers and access modifiers?",
    options: [
      "Both are same",
      "Specifiers define visibility, modifiers modify variables",
      "Specifiers are used for loops",
      "Modifiers are used in constructors only"
    ],
    answer: "Specifiers define visibility, modifiers modify variables"
  },
  {
    question: "What access modifiers can be used for a class?",
    options: ["private, protected", "public, default", "public, private", "final only"],
    answer: "public, default"
  },
  {
    question: "What access modifiers can be used for methods?",
    options: ["public, private, protected, default", "private only", "public only", "protected only"],
    answer: "public, private, protected, default"
  },
  {
    question: "What access modifiers can be used for variables?",
    options: ["public, private, protected, default", "private only", "public only", "static only"],
    answer: "public, private, protected, default"
  },
  {
    question: "What is final access modifier in Java?",
    options: [
      "Used to create constant variables",
      "Used to overload constructors",
      "Used to create static classes",
      "Used to enable polymorphism"
    ],
    answer: "Used to create constant variables"
  },
  {
    question: "What are abstract classes in Java?",
    options: [
      "Classes without name",
      "Classes that cannot be instantiated",
      "Classes with no variables allowed",
      "Classes with only static methods"
    ],
    answer: "Classes that cannot be instantiated"
  },
  {
    question: "Can we create constructors in abstract classes?",
    options: ["Yes", "No", "Only in Java 17+", "Only if static"],
    answer: "Yes"
  },
  {
    question: "What are abstract methods in Java?",
    options: [
      "Methods with body",
      "Methods without body",
      "Static methods",
      "Private methods"
    ],
    answer: "Methods without body"
  },
  {
    question: "What is an exception in Java?",
    options: [
      "Event that occurs during compilation",
      "Event that disrupts normal program flow at runtime",
      "Logical error",
      "Syntax error"
    ],
    answer: "Event that disrupts normal program flow at runtime"
  },
  {
    question: "Situations where exceptions may arise?",
    options: [
      "File not found",
      "Division by zero",
      "Invalid array index",
      "All of these"
    ],
    answer: "All of these"
  },
  {
    question: "What is exception handling in Java?",
    options: [
      "Handling syntax errors",
      "Handling runtime errors gracefully",
      "Handling memory leaks",
      "Handling threading issues"
    ],
    answer: "Handling runtime errors gracefully"
  },
  {
    question: "What is an error in Java?",
    options: [
      "Recoverable event",
      "Unrecoverable system failure",
      "Exception subclass",
      "Logical mistake"
    ],
    answer: "Unrecoverable system failure"
  },
  {
    question: "Advantages of exception handling?",
    options: [
      "Improves program flow",
      "Maintains normal application behavior",
      "Separates error handling code",
      "All of these"
    ],
    answer: "All of these"
  },
  {
    question: "In how many ways can we handle exceptions?",
    options: ["One", "Two", "Three", "Five"],
    answer: "Two"
  },
  {
    question: "Five keywords related to exception handling?",
    options: [
      "class, object, static, void, public",
      "try, catch, finally, throw, throws",
      "for, while, do, break, continue",
      "extends, super, this, case, switch"
    ],
    answer: "try, catch, finally, throw, throws"
  },
  {
    question: "Explain try and catch keywords?",
    options: [
      "try defines a block to test code, catch handles exceptions",
      "try handles exception, catch tests code",
      "catch runs always, try runs conditionally",
      "Both run at compile time"
    ],
    answer: "try defines a block to test code, catch handles exceptions"
  },
  {
    question: "Can we have try block without catch block?",
    options: ["Yes, if finally exists", "No", "Yes, always", "Only in Java 8+"],
    answer: "Yes, if finally exists"
  },
  {
    question: "Can we have multiple catch blocks for a try block?",
    options: ["Yes", "No", "Only one catch allowed", "Only if finally is present"],
    answer: "Yes"
  },
  {
    question: "What is the importance of the finally block in Java?",
    options: [
      "It handles exceptions",
      "It executes cleanup code regardless of exception",
      "It prevents exceptions",
      "It is optional and never executed"
    ],
    answer: "It executes cleanup code regardless of exception"
  },
  {
    question: "Can we have any code between try and catch blocks?",
    options: ["Yes", "No", "Only comments allowed", "Only print statements"],
    answer: "No"
  },
  {
    question: "Can we have any code between try and finally blocks?",
    options: ["Yes", "No", "Only comments allowed", "Only if no catch block exists"],
    answer: "No"
  },
  {
    question: "Can we catch more than one exception in a single catch block?",
    options: ["Yes, using multi-catch", "No", "Only checked exceptions", "Only runtime exceptions"],
    answer: "Yes, using multi-catch"
  },
  {
    question: "What are checked exceptions?",
    options: [
      "Exceptions checked at runtime",
      "Exceptions checked at compile time",
      "Errors thrown by JVM",
      "Exceptions that can't be caught"
    ],
    answer: "Exceptions checked at compile time"
  },
  {
    question: "What are unchecked exceptions in Java?",
    options: [
      "Exceptions checked at compile time",
      "Runtime exceptions not checked by compiler",
      "Errors thrown by JVM",
      "Exceptions that must be declared"
    ],
    answer: "Runtime exceptions not checked by compiler"
  },
  {
    question: "Difference between checked and unchecked exceptions?",
    options: [
      "Checked → compile time; Unchecked → runtime",
      "Checked → runtime; Unchecked → compile time",
      "Both are compile-time exceptions",
      "Both are runtime exceptions"
    ],
    answer: "Checked → compile time; Unchecked → runtime"
  },
  {
    question: "What is default exception handling in Java?",
    options: [
      "Handled by the JVM",
      "Handled by user code",
      "Handled by the compiler",
      "Not allowed in Java"
    ],
    answer: "Handled by the JVM"
  },
  {
    question: "What is the throw keyword used for?",
    options: [
      "To declare exceptions",
      "To explicitly throw an exception",
      "To catch an exception",
      "To ignore exceptions"
    ],
    answer: "To explicitly throw an exception"
  },
  {
    question: "Can we write any code after a throw statement?",
    options: ["Yes", "No", "Only print statements", "Only comments"],
    answer: "No"
  },
  {
    question: "Importance of throws keyword in Java?",
    options: [
      "Used to throw exceptions explicitly",
      "Used to declare exceptions for a method",
      "Used to catch exceptions",
      "Used to stop program execution"
    ],
    answer: "Used to declare exceptions for a method"
  },
  {
    question: "Importance of finally over return statement?",
    options: [
      "finally executes even if return executes",
      "return executes even if finally executes",
      "return overrides finally",
      "None"
    ],
    answer: "finally executes even if return executes"
  },
  {
    question: "When will finally block NOT execute?",
    options: [
      "When no exception occurs",
      "When a return statement exists",
      "When System.exit() is called",
      "When try has no catch"
    ],
    answer: "When System.exit() is called"
  },
  {
    question: "Can we use catch statement for checked exceptions?",
    options: ["Yes", "No", "Only sometimes", "Only if finally is present"],
    answer: "Yes"
  },
  {
    question: "What are user-defined exceptions?",
    options: [
      "Built-in Java exceptions",
      "Exceptions created by programmers",
      "Unchecked exceptions only",
      "Errors thrown by JVM"
    ],
    answer: "Exceptions created by programmers"
  },
  {
    question: "Can we rethrow the same exception from a catch handler?",
    options: ["Yes", "No", "Only checked exceptions", "Only runtime exceptions"],
    answer: "Yes"
  },
  {
    question: "Can we have nested try statements in Java?",
    options: ["Yes", "No", "Only inside catch", "Only inside finally"],
    answer: "Yes"
  },
  {
    question: "Importance of Throwable class?",
    options: [
      "Parent class of all errors and exceptions",
      "Used only for errors",
      "Used only for exceptions",
      "Used only for runtime exceptions"
    ],
    answer: "Parent class of all errors and exceptions"
  },
  {
    question: "When is ClassNotFoundException raised?",
    options: [
      "When a class cannot be found at runtime",
      "When file is missing",
      "When JVM crashes",
      "When package is missing"
    ],
    answer: "When a class cannot be found at runtime"
  },
  {
    question: "When will NoClassDefFoundError be raised?",
    options: [
      "When JVM cannot find a required class during runtime",
      "When syntax error occurs",
      "When package is missing",
      "When class name is too long"
    ],
    answer: "When JVM cannot find a required class during runtime"
  },
  {
    question: "What is a process?",
    options: [
      "A program in execution",
      "A Java thread",
      "A function call",
      "A memory block"
    ],
    answer: "A program in execution"
  },
  {
    question: "What is a thread in Java?",
    options: [
      "Lightweight subprocess",
      "A standalone program",
      "A compiler feature",
      "A memory region"
    ],
    answer: "Lightweight subprocess"
  },
  {
    question: "Difference between process and thread?",
    options: [
      "Process is heavy, thread is lightweight",
      "Thread is heavy, process is lightweight",
      "Both are same",
      "Thread has more memory than process"
    ],
    answer: "Process is heavy, thread is lightweight"
  },
  {
    question: "What is multitasking?",
    options: [
      "Executing multiple tasks simultaneously",
      "Running one program at a time",
      "Memory allocation",
      "Only thread creation"
    ],
    answer: "Executing multiple tasks simultaneously"
  },
  {
    question: "Types of multitasking?",
    options: [
      "Process-based and thread-based",
      "Static and dynamic",
      "Buffered and unbuffered",
      "File and memory"
    ],
    answer: "Process-based and thread-based"
  },
  {
    question: "Benefits of multithreaded programming?",
    options: [
      "Improved performance and resource sharing",
      "Slow processing",
      "More memory consumption",
      "Stops multitasking"
    ],
    answer: "Improved performance and resource sharing"
  },
  {
    question: "What is a thread in Java?",
    options: [
      "Small unit of a process",
      "Class file",
      "Package",
      "Variable"
    ],
    answer: "Small unit of a process"
  },
  {
    question: "Which Java API supports threads?",
    options: [
      "java.lang",
      "java.util",
      "java.io",
      "java.math"
    ],
    answer: "java.lang"
  },
  {
    question: "What is the main thread in Java?",
    options: [
      "The first thread executed by JVM",
      "The last thread",
      "User-created thread",
      "Thread in finally block"
    ],
    answer: "The first thread executed by JVM"
  },
  {
    question: "How many ways can we create threads in Java?",
    options: [
      "2 ways",
      "1 way",
      "3 ways",
      "4 ways"
    ],
    answer: "2 ways"
  },
  {
    question: "Creating thread by implementing Runnable means?",
    options: [
      "Implementing run() method from Runnable",
      "Extending Thread class",
      "Creating new process",
      "Using JVM commands"
    ],
    answer: "Implementing run() method from Runnable"
  },
  {
    question: "Creating thread by extending Thread class means?",
    options: [
      "Overriding run() method",
      "Creating interface",
      "Using static block",
      "Extending Object class"
    ],
    answer: "Overriding run() method"
  },
  {
    question: "Which is the best approach for creating a thread?",
    options: [
      "Implementing Runnable",
      "Extending Thread",
      "Using final class",
      "Using constructors"
    ],
    answer: "Implementing Runnable"
  },
  {
    question: "What is thread scheduler in Java?",
    options: [
      "Decides which thread runs next",
      "Stops threads",
      "Compiles code",
      "Creates processes"
    ],
    answer: "Decides which thread runs next"
  },
  {
    question: "Lifecycle of a thread includes?",
    options: [
      "New, Runnable, Running, Blocked, Terminated",
      "Start and Stop only",
      "Compile and Execute only",
      "Create and Destroy only"
    ],
    answer: "New, Runnable, Running, Blocked, Terminated"
  },
  {
    question: "Can we restart a dead thread in Java?",
    options: ["No", "Yes", "Only once", "Only in JVM mode"],
    answer: "No"
  },
  {
    question: "Can one thread block another thread?",
    options: ["Yes", "No", "Only main thread blocks", "Only daemon threads block"],
    answer: "Yes"
  },
  {
    question: "Can we restart a thread already started?",
    options: ["No", "Yes", "Only if paused", "Only main thread"],
    answer: "No"
  },
  {
    question: "Can we restart a thread already started in Java?",
    options: ["Yes", "No", "Only once", "Only if thread is sleeping"],
    answer: "No"
  },
  {
    question: "What happens if we don’t override run() method?",
    options: [
      "Thread will throw an exception",
      "Nothing happens, Thread class run() executes",
      "Program terminates",
      "Compiler error occurs"
    ],
    answer: "Nothing happens, Thread class run() executes"
  },
  {
    question: "Can we overload run() method in Java?",
    options: ["Yes", "No", "Only in interfaces", "Only if static"],
    answer: "Yes"
  },
  {
    question: "What is a lock in Java?",
    options: [
      "A tool to stop JVM",
      "A mechanism to allow only one thread to access resource",
      "A class loader",
      "A memory manager"
    ],
    answer: "A mechanism to allow only one thread to access resource"
  },
  {
    question: "In how many ways can we do synchronization in Java?",
    options: ["1 way", "2 ways", "3 ways", "4 ways"],
    answer: "2 ways"
  },
  {
    question: "What are synchronized methods?",
    options: [
      "Methods that run faster",
      "Methods that allow only one thread at a time",
      "Methods without return value",
      "Private-only methods"
    ],
    answer: "Methods that allow only one thread at a time"
  },
  {
    question: "When do we use synchronized methods in Java?",
    options: [
      "When multiple threads need shared resource",
      "When only one thread is present",
      "To improve performance",
      "To stop thread execution"
    ],
    answer: "When multiple threads need shared resource"
  },
  {
    question:
      "Can other threads execute other synchronized methods of SAME object when one thread holds the lock?",
    options: ["Yes", "No", "Only static ones", "Only private ones"],
    answer: "No"
  },
  {
    question:
      "If a thread is executing one synchronized method, can SAME THREAD access another synchronized method?",
    options: ["Yes", "No", "Only after lock release", "Only in static methods"],
    answer: "Yes"
  },
  {
    question: "What are synchronized blocks in Java?",
    options: [
      "Blocks used for exception handling",
      "Smaller synchronized sections for better performance",
      "Unused code sections",
      "Blocks executed without threads"
    ],
    answer: "Smaller synchronized sections for better performance"
  },
  {
    question:
      "When do we use synchronized blocks and what is their advantage?",
    options: [
      "To synchronize entire class",
      "When only a part of code needs locking, improves performance",
      "To create more threads",
      "To stop thread execution"
    ],
    answer: "When only a part of code needs locking, improves performance"
  },
  
];